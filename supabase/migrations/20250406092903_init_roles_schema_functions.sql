-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Create role and permission types as enums
CREATE TYPE public.app_role AS ENUM ('admin', 'moderator', 'regular');
CREATE TYPE public.app_permission AS ENUM (
  'user.read', 'user.write', 'user.delete',
  'post.read', 'post.write', 'post.delete',
  'comment.read', 'comment.write', 'comment.delete',
  'network.read', 'network.write',
  'settings.manage'
);

-- Create visibility type for profile visibility settings
CREATE TYPE public.visibility_type AS ENUM ('public', 'contacts', 'private');

-- Create basic profiles table that extends auth.users
CREATE TABLE public.users (
  id UUID PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE,
  avatar TEXT,
  bio TEXT,
  subtitle TEXT,
  join_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  role TEXT NOT NULL DEFAULT 'regular',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT email_validation CHECK (email ~* '^[A-Za-z0-9._%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$')
);

-- Create user preferences table
CREATE TABLE public.user_preferences (
  user_id UUID PRIMARY KEY REFERENCES public.users ON DELETE CASCADE,
  theme TEXT NOT NULL DEFAULT 'system',
  reduce_motion BOOLEAN NOT NULL DEFAULT FALSE,
  high_contrast BOOLEAN NOT NULL DEFAULT FALSE,
  email_notifications BOOLEAN NOT NULL DEFAULT TRUE,
  push_notifications BOOLEAN NOT NULL DEFAULT TRUE,
  profile_visibility visibility_type NOT NULL DEFAULT 'public'
);

-- Create posts table
CREATE TABLE public.posts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES public.users ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  likes INTEGER NOT NULL DEFAULT 0,
  comments INTEGER NOT NULL DEFAULT 0,
  weight NUMERIC NOT NULL DEFAULT 1,
  edited BOOLEAN NOT NULL DEFAULT FALSE
);

-- Create post tags table for many-to-many relationship
CREATE TABLE public.post_tags (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  post_id UUID NOT NULL REFERENCES public.posts ON DELETE CASCADE,
  tag TEXT NOT NULL,
  UNIQUE (post_id, tag)
);

-- Create comments table
CREATE TABLE public.comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES public.users ON DELETE CASCADE,
  post_id UUID NOT NULL REFERENCES public.posts ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create user connections/network table (for user relationships)
CREATE TABLE public.user_connections (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES public.users ON DELETE CASCADE,
  connected_user_id UUID NOT NULL REFERENCES public.users ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (user_id, connected_user_id),
  CONSTRAINT different_users CHECK (user_id <> connected_user_id)
);

-- Create network visualization data table for storing node/edge data
CREATE TABLE public.network_data (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  nodes JSONB NOT NULL DEFAULT '[]'::jsonb,
  edges JSONB NOT NULL DEFAULT '[]'::jsonb,
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create table for user roles (maps users to roles)
CREATE TABLE public.user_roles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role public.app_role NOT NULL,
  UNIQUE (user_id, role)
);

-- Create table for role permissions (maps roles to permissions)
CREATE TABLE public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role public.app_role NOT NULL,
  permission public.app_permission NOT NULL,
  UNIQUE (role, permission)
);

-- Insert default permissions for all roles
INSERT INTO public.role_permissions (role, permission)
VALUES
  -- Admin permissions
  ('admin', 'user.read'),
  ('admin', 'user.write'),
  ('admin', 'user.delete'),
  ('admin', 'post.read'),
  ('admin', 'post.write'),
  ('admin', 'post.delete'),
  ('admin', 'comment.read'),
  ('admin', 'comment.write'),
  ('admin', 'comment.delete'),
  ('admin', 'network.read'),
  ('admin', 'network.write'),
  ('admin', 'settings.manage'),
  
  -- Moderator permissions
  ('moderator', 'user.read'),
  ('moderator', 'post.read'),
  ('moderator', 'post.delete'),
  ('moderator', 'comment.read'),
  ('moderator', 'comment.delete'),
  ('moderator', 'network.read'),
  
  -- Regular user permissions
  ('regular', 'user.read'),
  ('regular', 'user.write'),
  ('regular', 'post.read'),
  ('regular', 'post.write'),
  ('regular', 'comment.read'),
  ('regular', 'comment.write'),
  ('regular', 'network.read');

-- Function to add user role to JWT claims
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event JSONB)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  claims JSONB;
  user_role public.app_role;
BEGIN
  SELECT role INTO user_role FROM public.user_roles WHERE user_id = (event->>'user_id')::UUID;
  claims := event->'claims';
  
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    claims := jsonb_set(claims, '{user_role}', 'null');
  END IF;
  
  event := jsonb_set(event, '{claims}', claims);
  RETURN event;
END;
$$;

-- Authorization function to check if a user has a specific permission
CREATE OR REPLACE FUNCTION public.authorize(requested_permission public.app_permission)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  bind_permissions INT;
  user_role public.app_role;
BEGIN
  SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;
  
  SELECT COUNT(*) INTO bind_permissions
  FROM public.role_permissions
  WHERE role_permissions.permission = requested_permission
  AND role_permissions.role = user_role;
  
  RETURN bind_permissions > 0;
END;
$$;

-- Check if users are connected for RLS policies
CREATE OR REPLACE FUNCTION public.are_users_connected(user_id1 UUID, user_id2 UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.user_connections
    WHERE (user_id = user_id1 AND connected_user_id = user_id2 AND status = 'accepted')
    OR (user_id = user_id2 AND connected_user_id = user_id1 AND status = 'accepted')
  );
END;
$$;

-- Get all users who can view a user's profile based on visibility settings
CREATE OR REPLACE FUNCTION public.can_view_user_profile(profile_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  visibility public.visibility_type;
  requesting_user_id UUID;
BEGIN
  requesting_user_id := auth.uid();
  
  -- Admin can always view profiles
  IF EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = requesting_user_id AND role = 'admin') THEN
    RETURN TRUE;
  END IF;
  
  -- Self can always view own profile
  IF profile_user_id = requesting_user_id THEN
    RETURN TRUE;
  END IF;
  
  -- Check profile visibility
  SELECT profile_visibility INTO visibility
  FROM public.user_preferences
  WHERE user_id = profile_user_id;
  
  CASE visibility
    WHEN 'public' THEN
      RETURN TRUE;
    WHEN 'contacts' THEN
      RETURN public.are_users_connected(profile_user_id, requesting_user_id);
    WHEN 'private' THEN
      RETURN FALSE;
    ELSE
      RETURN FALSE;
  END CASE;
END;
$$;

-- User functions for state management
CREATE OR REPLACE FUNCTION public.get_user(user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  result JSONB;
BEGIN
  IF NOT public.can_view_user_profile(user_id) THEN
    RAISE EXCEPTION 'Not authorized to view this user profile';
  END IF;

  SELECT json_build_object(
    'id', u.id,
    'name', u.name,
    'email', u.email,
    'avatar', u.avatar,
    'bio', u.bio,
    'subtitle', u.subtitle,
    'joinDate', u.join_date,
    'role', u.role,
    'createdAt', u.created_at
  ) INTO result
  FROM public.users u
  WHERE u.id = user_id;
  
  RETURN result;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_users()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT json_agg(
    json_build_object(
      'id', u.id,
      'name', u.name,
      'email', u.email,
      'avatar', u.avatar,
      'bio', u.bio,
      'subtitle', u.subtitle,
      'joinDate', u.join_date,
      'role', u.role,
      'createdAt', u.created_at
    )
  ) INTO result
  FROM public.users u
  WHERE public.can_view_user_profile(u.id);
  
  RETURN COALESCE(result, '[]'::jsonb);
END;
$$;

CREATE OR REPLACE FUNCTION public.update_user(
  p_user_id UUID,
  p_name TEXT DEFAULT NULL,
  p_email TEXT DEFAULT NULL,
  p_avatar TEXT DEFAULT NULL,
  p_bio TEXT DEFAULT NULL,
  p_subtitle TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  result JSONB;
BEGIN
  -- Check if the user is updating their own profile or is an admin
  IF p_user_id <> auth.uid() AND NOT public.authorize('user.write') THEN
    RAISE EXCEPTION 'Not authorized to update this user profile';
  END IF;
  
  -- Update only the provided fields
  UPDATE public.users
  SET
    name = COALESCE(p_name, name),
    email = COALESCE(p_email, email),
    avatar = COALESCE(p_avatar, avatar),
    bio = COALESCE(p_bio, bio),
    subtitle = COALESCE(p_subtitle, subtitle)
  WHERE id = p_user_id;
  
  -- Return the updated user
  SELECT json_build_object(
    'id', u.id,
    'name', u.name,
    'email', u.email,
    'avatar', u.avatar,
    'bio', u.bio,
    'subtitle', u.subtitle,
    'joinDate', u.join_date,
    'role', u.role,
    'createdAt', u.created_at
  ) INTO result
  FROM public.users u
  WHERE u.id = p_user_id;
  
  RETURN result;
END;
$$;

-- Post functions for state management
CREATE OR REPLACE FUNCTION public.get_posts()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT json_agg(
    json_build_object(
      'id', p.id,
      'userId', p.user_id,
      'content', p.content,
      'createdAt', p.created_at,
      'likes', p.likes,
      'comments', p.comments,
      'weight', p.weight,
      'edited', p.edited,
      'tags', (
        SELECT json_agg(tag)
        FROM public.post_tags
        WHERE post_id = p.id
      ),
      'commentsList', (
        SELECT json_agg(
          json_build_object(
            'id', c.id,
            'userId', c.user_id,
            'postId', c.post_id,
            'content', c.content,
            'createdAt', c.created_at
          )
        )
        FROM public.comments c
        WHERE c.post_id = p.id
      )
    )
  ) INTO result
  FROM public.posts p
  WHERE p.user_id = auth.uid() OR 
        public.can_view_user_profile(p.user_id);
  
  RETURN COALESCE(result, '[]'::jsonb);
END;
$$;

CREATE OR REPLACE FUNCTION public.get_post(post_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  result JSONB;
  post_user_id UUID;
BEGIN
  -- Get the user_id of the post
  SELECT user_id INTO post_user_id
  FROM public.posts
  WHERE id = post_id;
  
  -- Check if the user can view this post
  IF NOT (post_user_id = auth.uid() OR public.can_view_user_profile(post_user_id)) THEN
    RAISE EXCEPTION 'Not authorized to view this post';
  END IF;

  SELECT json_build_object(
    'id', p.id,
    'userId', p.user_id,
    'content', p.content,
    'createdAt', p.created_at,
    'likes', p.likes,
    'comments', p.comments,
    'weight', p.weight,
    'edited', p.edited,
    'tags', (
      SELECT json_agg(tag)
      FROM public.post_tags
      WHERE post_id = p.id
    ),
    'commentsList', (
      SELECT json_agg(
        json_build_object(
          'id', c.id,
          'userId', c.user_id,
          'postId', c.post_id,
          'content', c.content,
          'createdAt', c.created_at
        )
      )
      FROM public.comments c
      WHERE c.post_id = p.id
    )
  ) INTO result
  FROM public.posts p
  WHERE p.id = post_id;
  
  RETURN result;
END;
$$;

CREATE OR REPLACE FUNCTION public.add_post(
  p_content TEXT,
  p_weight NUMERIC DEFAULT 1,
  p_tags TEXT[] DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  new_post_id UUID;
  result JSONB;
  tag_item TEXT;
BEGIN
  -- Insert the new post
  INSERT INTO public.posts (user_id, content, weight)
  VALUES (auth.uid(), p_content, p_weight)
  RETURNING id INTO new_post_id;
  
  -- Insert tags if provided
  IF p_tags IS NOT NULL THEN
    FOREACH tag_item IN ARRAY p_tags
    LOOP
      INSERT INTO public.post_tags (post_id, tag)
      VALUES (new_post_id, tag_item);
    END LOOP;
  END IF;
  
  -- Return the created post
  SELECT public.get_post(new_post_id) INTO result;
  
  RETURN result;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_post(
  p_post_id UUID,
  p_content TEXT DEFAULT NULL,
  p_weight NUMERIC DEFAULT NULL,
  p_tags TEXT[] DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  post_user_id UUID;
  result JSONB;
  tag_item TEXT;
BEGIN
  -- Get the user_id of the post
  SELECT user_id INTO post_user_id
  FROM public.posts
  WHERE id = p_post_id;
  
  -- Check if the user owns this post or is an admin/moderator
  IF NOT (post_user_id = auth.uid() OR public.authorize('post.write')) THEN
    RAISE EXCEPTION 'Not authorized to update this post';
  END IF;

  -- Update only the provided fields
  UPDATE public.posts
  SET
    content = COALESCE(p_content, content),
    weight = COALESCE(p_weight, weight),
    edited = TRUE
  WHERE id = p_post_id;
  
  -- Update tags if provided
  IF p_tags IS NOT NULL THEN
    -- Delete existing tags
    DELETE FROM public.post_tags WHERE post_id = p_post_id;
    
    -- Insert new tags
    FOREACH tag_item IN ARRAY p_tags
    LOOP
      INSERT INTO public.post_tags (post_id, tag)
      VALUES (p_post_id, tag_item);
    END LOOP;
  END IF;
  
  -- Return the updated post
  SELECT public.get_post(p_post_id) INTO result;
  
  RETURN result;
END;
$$;

CREATE OR REPLACE FUNCTION public.remove_post(p_post_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  post_user_id UUID;
BEGIN
  -- Get the user_id of the post
  SELECT user_id INTO post_user_id
  FROM public.posts
  WHERE id = p_post_id;
  
  -- Check if the user owns this post or is an admin/moderator
  IF NOT (post_user_id = auth.uid() OR public.authorize('post.delete')) THEN
    RAISE EXCEPTION 'Not authorized to delete this post';
  END IF;

  -- Delete the post (cascade will handle related records)
  DELETE FROM public.posts WHERE id = p_post_id;
  
  RETURN TRUE;
END;
$$;

-- Comment functions for state management
CREATE OR REPLACE FUNCTION public.add_comment(
  p_post_id UUID,
  p_content TEXT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  new_comment_id UUID;
  post_user_id UUID;
  result JSONB;
BEGIN
  -- Get the user_id of the post
  SELECT user_id INTO post_user_id
  FROM public.posts
  WHERE id = p_post_id;
  
  -- Check if the user can comment on this post
  IF NOT (post_user_id = auth.uid() OR public.can_view_user_profile(post_user_id)) THEN
    RAISE EXCEPTION 'Not authorized to comment on this post';
  END IF;

  -- Insert the new comment
  INSERT INTO public.comments (user_id, post_id, content)
  VALUES (auth.uid(), p_post_id, p_content)
  RETURNING id INTO new_comment_id;
  
  -- Update comment count on the post
  UPDATE public.posts
  SET comments = comments + 1
  WHERE id = p_post_id;
  
  -- Return the created comment
  SELECT json_build_object(
    'id', c.id,
    'userId', c.user_id,
    'postId', c.post_id,
    'content', c.content,
    'createdAt', c.created_at
  ) INTO result
  FROM public.comments c
  WHERE c.id = new_comment_id;
  
  RETURN result;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_comment(
  p_comment_id UUID,
  p_content TEXT
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  comment_user_id UUID;
  result JSONB;
BEGIN
  -- Get the user_id of the comment
  SELECT user_id INTO comment_user_id
  FROM public.comments
  WHERE id = p_comment_id;
  
  -- Check if the user owns this comment or is an admin/moderator
  IF NOT (comment_user_id = auth.uid() OR public.authorize('comment.write')) THEN
    RAISE EXCEPTION 'Not authorized to update this comment';
  END IF;

  -- Update the comment
  UPDATE public.comments
  SET content = p_content
  WHERE id = p_comment_id;
  
  -- Return the updated comment
  SELECT json_build_object(
    'id', c.id,
    'userId', c.user_id,
    'postId', c.post_id,
    'content', c.content,
    'createdAt', c.created_at
  ) INTO result
  FROM public.comments c
  WHERE c.id = p_comment_id;
  
  RETURN result;
END;
$$;

CREATE OR REPLACE FUNCTION public.remove_comment(p_comment_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  comment_user_id UUID;
  post_id UUID;
BEGIN
  -- Get the user_id and post_id of the comment
  SELECT user_id, post_id INTO comment_user_id, post_id
  FROM public.comments
  WHERE id = p_comment_id;
  
  -- Check if the user owns this comment or is an admin/moderator
  IF NOT (comment_user_id = auth.uid() OR public.authorize('comment.delete')) THEN
    RAISE EXCEPTION 'Not authorized to delete this comment';
  END IF;

  -- Delete the comment
  DELETE FROM public.comments WHERE id = p_comment_id;
  
  -- Update comment count on the post
  UPDATE public.posts
  SET comments = GREATEST(0, comments - 1)
  WHERE id = post_id;
  
  RETURN TRUE;
END;
$$;

-- Network data functions
CREATE OR REPLACE FUNCTION public.get_network_data()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  result JSONB;
BEGIN
  -- Check if user can access network data
  IF NOT public.authorize('network.read') THEN
    RAISE EXCEPTION 'Not authorized to access network data';
  END IF;

  -- Get the latest network data
  SELECT json_build_object(
    'nodes', nodes,
    'edges', edges
  ) INTO result
  FROM public.network_data
  ORDER BY last_updated DESC
  LIMIT 1;
  
  RETURN COALESCE(result, '{"nodes":[], "edges":[]}'::jsonb);
END;
$$;

CREATE OR REPLACE FUNCTION public.update_network_data(
  p_nodes JSONB,
  p_edges JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  new_id UUID;
  result JSONB;
BEGIN
  -- Check if user can update network data
  IF NOT public.authorize('network.write') THEN
    RAISE EXCEPTION 'Not authorized to update network data';
  END IF;

  -- Insert new network data
  INSERT INTO public.network_data (nodes, edges)
  VALUES (p_nodes, p_edges)
  RETURNING id INTO new_id;
  
  -- Return the updated network data
  SELECT json_build_object(
    'nodes', nodes,
    'edges', edges
  ) INTO result
  FROM public.network_data
  WHERE id = new_id;
  
  RETURN result;
END;
$$;

-- UI preferences functions
CREATE OR REPLACE FUNCTION public.get_user_preferences(p_user_id UUID DEFAULT NULL)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  user_id UUID;
  result JSONB;
BEGIN
  -- Use provided user_id or default to current user
  user_id := COALESCE(p_user_id, auth.uid());
  
  -- Check if user is requesting their own preferences or is an admin
  IF user_id <> auth.uid() AND NOT public.authorize('settings.manage') THEN
    RAISE EXCEPTION 'Not authorized to access these user preferences';
  END IF;

  SELECT json_build_object(
    'theme', up.theme,
    'reduceMotion', up.reduce_motion,
    'highContrast', up.high_contrast,
    'emailNotifications', up.email_notifications,
    'pushNotifications', up.push_notifications,
    'profileVisibility', up.profile_visibility
  ) INTO result
  FROM public.user_preferences up
  WHERE up.user_id = user_id;
  
  RETURN result;
END;
$$;

CREATE OR REPLACE FUNCTION public.update_user_preferences(
  p_theme TEXT DEFAULT NULL,
  p_reduce_motion BOOLEAN DEFAULT NULL,
  p_high_contrast BOOLEAN DEFAULT NULL,
  p_email_notifications BOOLEAN DEFAULT NULL,
  p_push_notifications BOOLEAN DEFAULT NULL,
  p_profile_visibility visibility_type DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  result JSONB;
BEGIN
  -- Insert or update preferences
  INSERT INTO public.user_preferences (
    user_id,
    theme,
    reduce_motion,
    high_contrast,
    email_notifications,
    push_notifications,
    profile_visibility
  )
  VALUES (
    auth.uid(),
    COALESCE(p_theme, 'system'),
    COALESCE(p_reduce_motion, FALSE),
    COALESCE(p_high_contrast, FALSE),
    COALESCE(p_email_notifications, TRUE),
    COALESCE(p_push_notifications, TRUE),
    COALESCE(p_profile_visibility, 'public')
  )
  ON CONFLICT (user_id) 
  DO UPDATE SET
    theme = COALESCE(p_theme, user_preferences.theme),
    reduce_motion = COALESCE(p_reduce_motion, user_preferences.reduce_motion),
    high_contrast = COALESCE(p_high_contrast, user_preferences.high_contrast),
    email_notifications = COALESCE(p_email_notifications, user_preferences.email_notifications),
    push_notifications = COALESCE(p_push_notifications, user_preferences.push_notifications),
    profile_visibility = COALESCE(p_profile_visibility, user_preferences.profile_visibility);
  
  -- Return the updated preferences
  SELECT public.get_user_preferences() INTO result;
  
  RETURN result;
END;
$$;

-- Network connection functions
CREATE OR REPLACE FUNCTION public.add_connection(p_connected_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Prevent connecting to self
  IF p_connected_user_id = auth.uid() THEN
    RAISE EXCEPTION 'Cannot connect to yourself';
  END IF;
  
  -- Insert the connection request
  INSERT INTO public.user_connections (user_id, connected_user_id)
  VALUES (auth.uid(), p_connected_user_id)
  ON CONFLICT (user_id, connected_user_id) 
  DO NOTHING;
  
  RETURN TRUE;
END;
$$;

CREATE OR REPLACE FUNCTION public.accept_connection(p_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Update the connection status to accepted
  UPDATE public.user_connections
  SET status = 'accepted'
  WHERE user_id = p_user_id
  AND connected_user_id = auth.uid()
  AND status = 'pending';
  
  RETURN TRUE;
END;
$$;

CREATE OR REPLACE FUNCTION public.remove_connection(p_connected_user_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Delete connections in both directions
  DELETE FROM public.user_connections
  WHERE (user_id = auth.uid() AND connected_user_id = p_connected_user_id)
  OR (user_id = p_connected_user_id AND connected_user_id = auth.uid());
  
  RETURN TRUE;
END;
$$;

-- Apply Row Level Security (RLS) to tables
-- Users table RLS
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view profiles based on visibility settings"
ON public.users
FOR SELECT
USING (
  public.can_view_user_profile(id)
);

CREATE POLICY "Users can update their own profile"
ON public.users
FOR UPDATE
USING (
  id = auth.uid()
);

-- User preferences RLS
ALTER TABLE public.user_preferences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own preferences"
ON public.user_preferences
FOR SELECT
USING (
  user_id = auth.uid() OR 
  public.authorize('settings.manage')
);

CREATE POLICY "Users can update own preferences"
ON public.user_preferences
FOR UPDATE
USING (
  user_id = auth.uid()
);

-- Posts table RLS
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view posts from connected users"
ON public.posts
FOR SELECT
USING (
  user_id = auth.uid() OR
  public.can_view_user_profile(user_id)
);

CREATE POLICY "Users can create their own posts"
ON public.posts
FOR INSERT
WITH CHECK (
  user_id = auth.uid()
);

CREATE POLICY "Users can update their own posts"
ON public.posts
FOR UPDATE
USING (
  user_id = auth.uid()
);

CREATE POLICY "Users can delete their own posts"
ON public.posts
FOR DELETE
USING (
  user_id = auth.uid()
);

CREATE POLICY "Moderators can delete any post"
ON public.posts
FOR DELETE
USING (
  public.authorize('post.delete')
);

-- Continued from previous section

-- Comments table RLS
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view comments on visible posts"
ON public.comments
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM public.posts p
    WHERE p.id = post_id
    AND (p.user_id = auth.uid() OR public.can_view_user_profile(p.user_id))
  )
);

CREATE POLICY "Users can create comments on visible posts"
ON public.comments
FOR INSERT
WITH CHECK (
  user_id = auth.uid() AND
  EXISTS (
    SELECT 1 FROM public.posts p
    WHERE p.id = post_id
    AND (p.user_id = auth.uid() OR public.can_view_user_profile(p.user_id))
  )
);

CREATE POLICY "Users can update their own comments"
ON public.comments
FOR UPDATE
USING (
  user_id = auth.uid()
);

CREATE POLICY "Users can delete their own comments"
ON public.comments
FOR DELETE
USING (
  user_id = auth.uid()
);

CREATE POLICY "Moderators can delete any comment"
ON public.comments
FOR DELETE
USING (
  public.authorize('comment.delete')
);

-- Post tags table RLS
ALTER TABLE public.post_tags ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view all post tags"
ON public.post_tags
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM public.posts p
    WHERE p.id = post_id
    AND (p.user_id = auth.uid() OR public.can_view_user_profile(p.user_id))
  )
);

CREATE POLICY "Users can add tags to their own posts"
ON public.post_tags
FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.posts p
    WHERE p.id = post_id
    AND p.user_id = auth.uid()
  )
);

CREATE POLICY "Users can delete tags from their own posts"
ON public.post_tags
FOR DELETE
USING (
  EXISTS (
    SELECT 1 FROM public.posts p
    WHERE p.id = post_id
    AND p.user_id = auth.uid()
  )
);

-- User connections table RLS
ALTER TABLE public.user_connections ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own connections"
ON public.user_connections
FOR SELECT
USING (
  user_id = auth.uid() OR connected_user_id = auth.uid()
);

CREATE POLICY "Users can create connection requests"
ON public.user_connections
FOR INSERT
WITH CHECK (
  user_id = auth.uid()
);

CREATE POLICY "Users can update connection requests sent to them"
ON public.user_connections
FOR UPDATE
USING (
  connected_user_id = auth.uid()
);

CREATE POLICY "Users can delete their own connections"
ON public.user_connections
FOR DELETE
USING (
  user_id = auth.uid() OR connected_user_id = auth.uid()
);

-- Network data table RLS
ALTER TABLE public.network_data ENABLE ROW LEVEL SECURITY;

CREATE POLICY "All users can view network data"
ON public.network_data
FOR SELECT
USING (
  public.authorize('network.read')
);

CREATE POLICY "Only admins can modify network data"
ON public.network_data
FOR ALL
USING (
  public.authorize('network.write')
);

-- User roles table RLS
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own roles"
ON public.user_roles
FOR SELECT
USING (
  user_id = auth.uid() OR public.authorize('user.read')
);

CREATE POLICY "Only admins can modify roles"
ON public.user_roles
FOR ALL
USING (
  public.authorize('user.write')
);

-- Role permissions table RLS
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "All users can view role permissions"
ON public.role_permissions
FOR SELECT
USING (true);

CREATE POLICY "Only admins can modify role permissions"
ON public.role_permissions
FOR ALL
USING (
  public.authorize('settings.manage')
);

-- Grant necessary permissions to Supabase auth
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;
GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;
GRANT ALL ON TABLE public.role_permissions TO supabase_auth_admin;
REVOKE ALL ON TABLE public.role_permissions FROM authenticated, anon, public;

-- Grant access to authenticated users
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT INSERT, UPDATE, DELETE ON public.users, 
                                public.user_preferences, 
                                public.posts, 
                                public.post_tags, 
                                public.comments, 
                                public.user_connections
                             TO authenticated;

-- Grant execute permission on functions
GRANT EXECUTE ON FUNCTION public.authorize TO authenticated;
GRANT EXECUTE ON FUNCTION public.are_users_connected TO authenticated;
GRANT EXECUTE ON FUNCTION public.can_view_user_profile TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_users TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_user TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_posts TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_post TO authenticated;
GRANT EXECUTE ON FUNCTION public.add_post TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_post TO authenticated;
GRANT EXECUTE ON FUNCTION public.remove_post TO authenticated;
GRANT EXECUTE ON FUNCTION public.add_comment TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_comment TO authenticated;
GRANT EXECUTE ON FUNCTION public.remove_comment TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_network_data TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_network_data TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_user_preferences TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_user_preferences TO authenticated;
GRANT EXECUTE ON FUNCTION public.add_connection TO authenticated;
GRANT EXECUTE ON FUNCTION public.accept_connection TO authenticated;
GRANT EXECUTE ON FUNCTION public.remove_connection TO authenticated;

-- Create triggers for automatic data updates

-- Trigger to ensure user preferences are created when a user is created
CREATE OR REPLACE FUNCTION public.create_user_preferences_on_user_creation()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.user_preferences (user_id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$$;

CREATE TRIGGER create_user_preferences_trigger
AFTER INSERT ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.create_user_preferences_on_user_creation();

-- Trigger to update post count in user profile
CREATE OR REPLACE FUNCTION public.update_post_count_on_user_profile()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- Increment post count when a new post is created
    -- This would be implemented if there was a posts_count column in users table
    -- UPDATE public.users SET posts_count = posts_count + 1 WHERE id = NEW.user_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    -- Decrement post count when a post is deleted
    -- UPDATE public.users SET posts_count = GREATEST(0, posts_count - 1) WHERE id = OLD.user_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;

CREATE TRIGGER update_post_count_trigger
AFTER INSERT OR DELETE ON public.posts
FOR EACH ROW
EXECUTE FUNCTION public.update_post_count_on_user_profile();

-- Trigger to clean up user connections when a user is deleted
CREATE OR REPLACE FUNCTION public.clean_up_connections_on_user_deletion()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Delete all connections involving the deleted user
  DELETE FROM public.user_connections
  WHERE user_id = OLD.id OR connected_user_id = OLD.id;
  RETURN OLD;
END;
$$;

CREATE TRIGGER clean_up_connections_trigger
BEFORE DELETE ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.clean_up_connections_on_user_deletion();

-- Initial setup for admin user role
-- This function is called once manually to set up the initial admin user
CREATE OR REPLACE FUNCTION public.setup_initial_admin(admin_email TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  admin_id UUID;
BEGIN
  -- Find the user by email
  SELECT id INTO admin_id
  FROM public.users
  WHERE email = admin_email;
  
  IF admin_id IS NULL THEN
    RAISE EXCEPTION 'User with email % not found', admin_email;
  END IF;
  
  -- Add admin role to user
  INSERT INTO public.user_roles (user_id, role)
  VALUES (admin_id, 'admin')
  ON CONFLICT (user_id, role) DO NOTHING;
  
  -- Update user role in users table
  UPDATE public.users
  SET role = 'admin'
  WHERE id = admin_id;
  
  RETURN TRUE;
END;
$$;

-- Index creation for performance optimization
CREATE INDEX idx_posts_user_id ON public.posts (user_id);
CREATE INDEX idx_comments_post_id ON public.comments (post_id);
CREATE INDEX idx_comments_user_id ON public.comments (user_id);
CREATE INDEX idx_post_tags_post_id ON public.post_tags (post_id);
CREATE INDEX idx_user_connections_user_id ON public.user_connections (user_id);
CREATE INDEX idx_user_connections_connected_user_id ON public.user_connections (connected_user_id);
CREATE INDEX idx_user_connections_status ON public.user_connections (status);
CREATE INDEX idx_user_preferences_user_id ON public.user_preferences (user_id);
CREATE INDEX idx_user_roles_user_id ON public.user_roles (user_id);
CREATE INDEX idx_role_permissions_role ON public.role_permissions (role);